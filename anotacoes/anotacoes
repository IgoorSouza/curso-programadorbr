
  HTML

    negrito = <b> (formatação) e <strong> (semântica de destaque)
    itálico = <i> (formatação) e <em> (semântica de destaque)
    texto riscado = <del>
    marca-texto = <mark>
    letra pequena = <small>
    texto mais "baixo" na linha = <sub>
    texto que foi inserido na página (fica sublinhado) = <ins>

    <figure> (tag usada para "agrupar" uma imagem com sua legenda)
    <img src="" alt="">
    <figcaption></figcaption> (aqui vai a legenda da imagem)
    </figure>

    link para número de telefone: 
      <a href="tel:+(numero)"></a>
        
    link para o app do Whatsapp: 
      <a href="whatsapp://(numero)"></a>

    link para o app do Instagram:
      <a href="instagram://"></a>  (abre o feed do Instagram)
      <a href="instagram://user?username=(perfil)"></a> (abre o perfil especificado)

    link para mandar email: 
      <a href="mailto:(endereço de email)"></a>

    direcionar o usuário para algum conteúdo específico da página:
      <a href="#(id atribuído ao conteúdo)"></a>

    adicionar vídeo: 
      <video src=""></video>
        atributos: 
          não precisam de valor: controls, autoplay, muted, loop,
          precisam de valor: width, height, poster = src(""), preload = "auto" (inicia o carregamento do vídeo após a página carregar) / "none" (não carrega o vídeo enquanto o usuário não der play) / "metadata" (carrega apenas alguns dados sobre o vídeo)
          Obs.: quando preload e autoplay são usados juntos, o autoplay possui prioridade
                              
  CSS

    conteúdo em excesso ("vazando" do lugar onde deveria estar):
    overflow/overflow-y/overflow-x: auto (adiciona automaticamente uma barra de rolagem) / scroll (adiciona um barra de rolagem) / hidden (esconde o conteúdo em excesso)

    colocar imagem em lista não ordenada (a imagem PRECISA ser 16x16):
      list-style-image: url('(imagem)');
      
    Position
      static: padrão, não permite uso de top, bottom, left, right.

      Permitem uso de top, bottom, left, right:

        relative: posição com base no posicionamento original do elemento. É como se o elemento definido como relative ainda estivesse ocupando seu espaço original, mesmo não estando nele.

        absolute: se posiciona de acordo com o elemento pai, desde que este não tenha posicionamento static. Se o pai tiver posicionamento static, o elemento se posicionará em relação ao primeiro elemento não estático acima dele. É como se o elemento definido como absolute funcionasse de forma independente, sem afetar a posição de outros elementos.

        fixed: mantém o elemento fixo em relação à viewport. O elemento é removido de sua posição original, funcionando de forma independente.

        sticky: o elemento mantém seu posicionamento original, porém continua na tela caso saia da viewport.

    Variáveis
      :root {
        --(nome da variável): (valor);
      }

      (elemento) {
        (propriedade): var(--(nome da variavel));
      }

        Ex.: 
          :root {
            --cor: red;
          }

          div {
            background-color: var(--cor);
          }

    Flexbox
      Aplicáveis ao elemento pai: 
        display: flex = organiza os elementos filhos de forma que possam ser contidos dentro do elemento pai, mesmo que seja necessário alterar seus tamanhos para isso

        flex-direction: 
          row = o elemento que recebe "flex-direction: row" se comporta como uma grande linha com orientação da esquerda para a direita, onde seus elementos filhos se organizam de forma a ficar dentro dessa linha. Para isso, cada elemento filho se torna uma coluna e, por padrão, irá ocupar toda a altura do elemento pai

          row-reverse = similar ao row, porém a orientação da linha é da direita para a esquerda, a ordem dos elementos é invertida e os elementos são fixados à direita

          column = o elemento que recebe "flex-direction: column" se comporta como uma grande coluna com orientação de cima para baixo, onde seus elementos filhos se organizam de forma a ficar dentro dessa coluna. Para isso, cada elemento filho se torna uma linha e, por padrão, irá ocupar toda a largura do elemento pai

          column-reverse = similar ao column, porém a orientação da coluna é de baixo para cima, a ordem dos elementos é invertida e os elementos são alocados para a parte de baixo

        flex-wrap: wrap = mantém o tamanho definido dos elementos e forma mais linhas ou colunas para contê-los

        flex-wrap: wrap-reverse = inverte a ordem das linhas ou colunas e as posiciona ao lado contrário do natural

        flex-flow: (flex-direction flex-wrap) = redução das propriedades flex-direction e flex-wrap em uma só propriedade

        justify-content: posiciona os elementos filhos em relação ao elemento pai
          flex-start = padrão

          flex-end = fixa os elementos na extremidade "final" do elemento pai

          center = centraliza os elementos

          space-around = faz uma borda ao redor do elemento com medidas iguais nos dois lados

          space-between = mantém espaçamento uniforme entre os elementos

          space-evenly = mantém espaçamento uniforme entre a borda e os elementos e também entre os elementos

      align-items: alinha todos os elementos de acordo com o flex-direction. Caso seja row, alinhará os elementos verticalmente, caso seja column, alinhará os elementos horizontalmente
        stretch = padrão

        flex-start = posiciona os elementos no início da linha

        flex-end = posiciona os elementos no fim da linha ou coluna

        center = centraliza os elementos

      align-content: similiar ao align-items, porém não se aplica aos elementos, mas sim às linhas ou colunas. É o espaçamento entre linhas ou entre colunas.
        stretch = padrão

        center = centraliza as linhas/colunas

        flex-start = posiciona as linhas/colunas no início do elemento pai

        flex-end = posiciona as linhas/colunas no fim do elemento pai

        space-around = faz uma borda ao redor das linhas/colunas com medidas iguais nos dois lados

        space-between = mantém espaçamento uniforme entre as linhas/colunas

      Aplicáveis aos elementos filhos:
        flex-shrink: 0 / 1 (padrão) = define se o tamanho do elemento será passível de redução (0 = não flexível / 1 = flexível)

        flex-grow: 0 (padrão) / 1 = define se o tamanho do elemento será passível de expansão (0 = não flexível / 1 = flexível / 2 ou maior = multiplicador de tamanho em relação ao tamanho dos outros elementos)

        order: 0 / n / -n = define a ordem dos elementos. Por padrão, todos os elementos possuem ordem 0. Quanto maior a ordem, mais "depois" o elemento ficará e, da mesma forma, quanto menor for a ordem, mais "antes" o elemento irá se posicionar.

        align-self: stretch / flex-start / flex-end / center = posiciona um elemento específico.
        
    Grid
      Aplicáveis ao elemento pai (container da grid)
        display: grid = define o elemento como uma grid (como se fosse uma tabela com linhas e colunas)

        Obs.: as grids possuem um valor de tamanho exclusivo: o fr. Divide a grid em frações e as distribui entre as linhas e/ou colunas de acordo com os valores passado.
          Ex.: grid-template-rows: 1fr 3fr 1fr = 1 fração / 3 frações / 1 fração

        grid-template-rows: N% (ocupa uma porcentagem de tamanho da grid) / Npx (tamanho fixo em pixeis) / Nfr (ocupa um número de frações da grid) / auto (se adapta ao tamanho da tela) = cria linhas dentro da grid. Cada valor passado representa uma linha.

        grid-template-columns: N% (ocupa uma porcentagem de tamanho da grid) / Npx (tamanho fixo em pixeis) / Nfr (ocupa um número de frações da grid) / auto (se adapta ao tamanho da tela) = cria colunas dentro da grid. Cada valor passado representa uma coluna.
          
        grid-template: linhas / colunas = redução das propriedades grid-template-rows e grid-template-columns em apenas uma.

        grid-row-gap: Npx =  espaçamento entre linhas.
        grid-column-gap: Npx = espaçamento entre colunas.

        grid-gap: Npx = redução das propriedades grid-row-gap e grid-column-gap em apenas uma. Define o mesmo espaçamento entre as linhas e entre as colunas.

        justify-items: stretch (padrão) / flex-start /  flex-end / center = posiciona horizontalmente os elementos dentro de seu espaço na grid 

        align-items: stretch (padrão) / flex-start / flex-end / center = posiciona verticalmente os elementos dentro de seu espaço na grid
            
        justify-content: stretch (padrão) / flex-start / flex-end / space-around / space-between / space-evenly = posiciona horizontalmente cada "bloco" da grid em relação ao elemento pai

        align-content: stretch (padrão) / flex-start / flex-end / space-around / space-between / space-evenly = posiciona verticalmente cada "bloco" da grid em relação ao elemento pai

        Grid Areas:
            1. Atribuir a propriedade grid-area: (nome) a todos os elementos da grid;
            2. No container da grid, adicionar a propriedade grid-template-areas: "(nome) (nome) (nome) ...", onde cada elemento adicionado forma uma coluna e tudo que está entre as aspas forma uma linha.
              Ex.: 
                .item1 {
                  grid-area: a1;
                }

                .item2 {
                  grid-area: a2;
                }

                .container {
                  grid-template-areas: "a1 a2 a2"
                                      "a2 a1 a1"       
                }

                No caso acima, são formadas duas linhas, ambas divididas em três partes (colunas), onde o elemento a1 ocupa 1/3 da primeira e 2/3 da segunda e o elemento a2 ocupa 2/3 da primeira e 1/3 da segunda.
      
      Aplicáveis aos elementos filhos (dentro da grid):  
        grid-column-start & grid-row-start: N = define onde um elemento irá "começar" seu posicionamento dentro da grid

        grid-column-end & grid-row-end: N / span N (expande o elemento)= define onde um elemento irá "terminar" seu posicionamento dentro da grid

    
    Animações em CSS
      Declara-se uma animação com suas propriedades e passa-se o nome e o tempo de duração dessa animação para o elemento que vai utilizá-la.

        Declaração da animação: 
        
          @keyframes (nome da animação) {
            from {(propriedade)}
            to {(propriedade)}
          }

        Passando para o elemento:

          elemento {
            animation-name: (nome da animação);
            animation-duration: (duração da animação);
          }
        
        Ex.:

          @keyframes changeColor {
            from {background-color: red}
            to {background-color: blue}
          }

          .box {
            animation-name: changeColor;
            animation-duration: 3s;
          }
      
      É possível utilizar porcentagens no lugar de "from" e "to":
        0% {background-color: red}
        50% {background-color: green}
        100% {background-color: blue}

      É possível também colocar mais de uma propriedade em um estado da animação. 
          0% {background-color: red; width: 100%}
          100% {background-color: blue; width: 50%}

      Animation delay: atrasa o início da animação de acordo o tempo determinado. Declarada no elemento que recebe a animação.
          animation-delay: (tempo de atraso);

        Também é possível colocar valores de tempo negativos, que resultam no início imediato da animação a partir do ponto especificado.
          Ex.: animation-duration: 6s
               animation-delay: -3s

            Nesse exemplo, a animação irá começar a ser reproduzida a partir de sua metade (3s).
        
      Loop de animação: é possível definir quantas vezes uma animação será repetida ou, ainda, se ela irá se repetir infinitamente. Declarada no elemento que recebe a animação.
          animation-iteration-count: (numero de repetições)
          animation-iteration-count: infinite

      Direção da animação: define se a animação será reproduzida do início para o final, do final para o início ou se será alternada (só é possível utilizar animações alternadas quando há repetição da mesma). Declarada no elemento que recebe a animação.
          animation-direction:
            reverse = a animação é reproduzida ao contrário.

            alternate = a animação é reproduzida de forma alternada, começando pela direção padrão.

            alternate-reverse = a animação é reproduzida de forma alternada, começando pela direção contrária.
      
      Animation fill: define o estado do elemento após ou antes da animação ser reproduzida. Declarada no elemento que recebe a animação.
          animation-fill-mode: 
            forwards = o elemento mantém o estado final da animação.

            backwards = funciona apenas quando há delay na animação. Posiciona a animação no seu primeiro estado e só inicia a execução após o delay acabar.

            both = aplica ambas as propriedades forwards e backwards.
      
     Timing function: define a velocidade que uma animação é reproduzida. Declarada no elemento que recebe a animação
        animation-timing-function: 
          linear = mesma velocidade durante toda a animação.
        
          ease, ease-in, ease-out, ease-in-out = diferentes velocidades ao longo da animação.

    Shorthand: declarada no elemento que recebe a animação.
      animation: nome duração timing-function delay iteration-count direction fill-mode;

  Transições / Transitions: 
    transition-property: (propriedade) = define qual propriedade irá receber a transição. É possível selecionar todas as propriedades de um elemento utilizando o valor "all".

    transition-duration: (duração da transição).

    transition-delay: (tempo de atraso) = atraso na execução da transição.
          
    transition-timing-function: linear/ease/ease-in/ease-out/ease-in-out = velocidade de reprodução da transição.

    Shorthand:
      transition: property duration delay timing-function;

  JavaScript
  
    Objetos

      Declaração:
        var (nome do objeto) = {propriedade: valor}
          Ex.: var aluno = {nome: "Igor", nota1: 7.5}
      
      Acessando propriedades de um objeto:
        (nome do objeto).(propriedade) / (nome do objeto)["(propriedade)"]
          Ex.: aluno.nome / aluno["nome"]

      Um objeto pode ter arrays dentro de si.
        Ex.: var aluno = {notas[1.5, 2.0, 3.5]}
        console.log(aluno.notas / aluno["notas"])= mostra todo o vetor "notas"
        console.log(aluno.notas[x] / aluno["notas"][x]) = mostra um valor específico do vetor "notas"

      Inserindo propriedades em um objeto já existente:
        (nome do objeto).(nova propriedade) = (valor)
        (nome do objeto)["(nova propriedade)"] = (valor)
        var x = (nova propriedade) -> (nome do objeto).x = (valor)
                                      (nome do objeto)[x] = (valor)

      Funções em objetos (métodos):
        var (nome do objeto) = {(propriedade que recebe o método) = function(){}}
        Ex.: var objeto = {
                media = function(n1, n2){
                  return (n1 + n2) / 2
                }
              }

            OU

            var objeto = {
              media = calcMedia
            }

            function calcMedia(n1, n2) {
              return (n1 + n2) / 2
            }

        elemento "this": se refere ao objeto em que ele está inserido. É usado nos métodos para 

    document.getElementById("(id do elemento)")
    document.getElementsByClassName("(class)") = forma um array com todos os elementos da classe especificada
    document.getElementsByTagName("h1") = forma um array com todos os elementos da tag especificada

    .innerHTML = conteúdo HTML do elemento (incluindo tags)
    .innerText = apenas o texto que está sendo mostrado
    .textContent = tudo aquilo que está dentro do texto

    Modificando elementos HTML:
      (elemento).(atributo) = "(valor)"
        Ex.: p.style = "color:blue"
        Ex.2: p.className = "paragrafo"

    Acessando atributos de um elemento HTML:
      (elemento).getAttribute("(atributo)")
        Ex.: p.getAttribute("meuAtt")

    Modificando ou adicionando atributos a um elemento HTML:
      (elemento).setAttribute("(atributo)", "(valor)")
        Ex.: p.setAttribute("meuAtt", "novo nome")
        IMPORTANTE: quando for utilizar um atributo inventado, colocar 
        "data-(atributo)" no HTML e selecioná-lo no JS utilizando (elemento).dataset.(atributo)
          Ex.: HTML = <ul id="lista" data-num="5"></ul> / JS = lista.dataset.num

    Modificando ou adicionando estilos CSS a um elemento HTML: 
      (elemento).style.(tag CSS) = "(valor)"
        Ex.: p.style.backgroundColor = "red"

    Acessando os elementos filhos de um elemento pai:
      (elemento).children = forma um array com todos os elementos filhos
      (elemento).children[x] = pega um elemento específico do array de filhos

    Acessando o elemento pai de um elemento filho:
      (elemento).parentElement

    *Biblioteca importante: Math

    JSON:

      JSON.stringify() = transforma um objeto em uma string
      JSON.parse() = transforma uma string em um objeto

    Local Storage (guarda os dados em uma string e os mantém mesmo após reiniciar a página):

      localStorage.setItem("(chave)", "(string)") = guarda o dado

      localStorage.getItem("(chave)") = busca o dado solicitado que foi guardado anteriormente

      localStorage.removeItem("(chave)") = remove o dado da memória

      localStorage.clear() = apaga toda a memória

      OBS.: os dados só ficam disponíveis dentro de seu próprio domínio.
      OBS2.: usar JSON para converter os dados que não são strings.
    
    Temporizador e Intervalo:

      Temporizador: setTimeout((função), tempo (em milissegundos)) = depois de disparado, executa uma função após o tempo determinado

      Intervalo: setInterval((função), tempo (em milissegundos)) = depois de disparado, executa uma função repetidamente de acordo com o intervalo de tempo determinado

      Interromper setTimeout: clearTimeout((variável correspondente ao timeout))

      Interromper setInterval: clearInterval((variável correspondente ao interval))

    Vídeos

      .play() = iniciar/continuar o vídeo
      .pause() = pausar o vídeo
      .currentTime = define ou retorna o momento atual do vídeo
      .playbackRate = velocidade de reprodução do vídeo

    Canvas
      Importante: definir o tamanho do canvas na própria tag HTML (<canvas>) e não pelo CSS

      Necessário pegar o contexto
        Ex.: let tela = document.getElementById("tela")
             let ctx = tela.getContext("2d")

      (contexto).moveTo(x, y) = coloca o "pincel" na coordenada especificada
        Ex.: ctx.moveTo(0, 0)
      
      (contexto).lineTo(x, y) = traça uma linha do ponto inicial do contexto até a coordenada especificada
        Ex.: ctx.lineTo(250, 250)

      (contexto).stroke() = desenha a linha. Obrigatório para a linha aparecer.

      (contexto).strokeStyle = "(valor)" -> define estilo para a linha.
        Ex.: ctx.strokeStyle = "red"

      (contexto).lineWidth = (valor) -> define a largura da linha. Obrigatório vir antes do stroke.

      Retângulos:

        Preenchido:
          (contexto).fillRect(x, y, width, height) -> define onde será iniciado o retângulo (preenchido) e suas respectivas largura e altura

          (contexto).fillStyle = "(valor)" -> define o estilo do preenchimento do retângulo

        Vazio: 
          (contexto).strokeRect(x, y, width, height) -> define onde será iniciado o retângulo (vazio) e suas respectivas largura e altura

          (contexto).strokeStyle = "(valor)" -> define o estilo da borda do retângulo
        
        Preenchido e borda com estilos diferentes: 
          (contexto).rect(x, y, width, height) -> define onde será iniciado o retângulo (vazio) e suas respectivas largura e altura

          (contexto).fillStyle = "(valor)" -> define o estilo do preenchimento do retângulo

          (contexto).strokeStyle = "(valor)" -> define o estilo da borda do retângulo

          (contexto).fill() = define o preenchimento (faz ele aparecer)
          (contexto).stroke() = define a borda (faz ela aparecer)

          (contexto).clearRect(x, y, width, height) -> cria um espaço vazio dentro do retângulo

    (contexto).beginPath() -> cria um caminho (duas ou mais linhas seguidas. Ex.: uma linha começa em 0,0 e vai até 10,10; então cria-se uma segunda linha que, ao invés de começar em 0,0; começa em 10,10; onde a primeira linha terminou, e vai até 20,20)

    (contexto).closePath() -> cria linhas que fecham o caminho automaticamente.

    Círculos / Arcos
      Importante: Necessário criar um caminho para fazer círculos ou arcos

      (contexto).arc(x, y, raio, angulo inicial, angulo final)
        OBS.: x e y representam o ponto central do círculo; os ângulos são medidos em radianos; usar variáveis para passar os valores do círculo.

    Animação 

      Ver aula: https://programadorbr.club.hotmart.com/lesson/qoODn0zgeP/canvas-animacao

    Imagens dentro de canvas

      Primeira maneira:
        1. Definir imagem no HTML com display: none 
        2. (contexto).drawImage((variável com a imagem), x, y, width, height)

      Segunda maneira:
        1. Definir variável com valor "new Image()"
        2. (variável).src = "(imagem)"
        3. (variável).onload = (função)
        4. função {(contexto).drawImage(this, x, y, width, height)} 
          Obs.: também é possível usar this.naturalWidth no lugar de width e this.naturalHeight no lugar de height (e fazer operações com esses tamanhos)

    Strict mode ("use strict") = bloqueia o uso de variáveis que não foram declaradas e impede a criação automática delas, exigindo o uso de var, let ou const para criar variáveis.

    This = se refere ao contexto em que está definido.
    
    Bind ([função].bind([contexto])) = dá contexto a uma função.

    Arrow function ( () => {} ) = simplifica o código de uma função. Entretanto, arrow functions NÃO suportam this e bind e seu this se refere sempre ao elemento window.
      Ex.: dobro(x) {                   dobro = (x) => {
              console.log(x * 2)   ==     console.log(x * 2)
          }                             }
      
      Ex2.: dobro(x) {           
              return (x * 2)   ==   dobro = (x) => x * 2
            }
    
    Callback = uma função recebe outra função como paramêtro e a executa dentro de si.

    Promises = São objetos que recebem uma função como argumento e retornam se uma ação assíncrona foi realizada com sucesso ou se falhou.
      Ex.: let promise = new Promise(function(resolve, reject) {
        setTimeout(()=> {
          usuarios.push(nome);
          let error = false;

          if (!error) {
            resolve();
          } else {
            reject({ msg: "Erro" })
          }
        }, 1000)
      })
      return promise;

    função.then([função]) = executa uma segunda função após executar a primeira. Bastante usado com promises.

    Async Await = faz com que o código seja "pausado" até que a função seja completamente resolvida.
      Ex.: async function executar(){
              await inserirUsuario()
              listarUsuarios()
           }

    Filter: (array).filter([função]) = filtra as informações de um array e retorna outro array com as informações filtradas.
      
      Ex.: let alunosComMenosde30 = alunos.filter(temMenosde30)
           function temMenosde30(aluno) {
              return aluno.idade < 30 
           }
    
        Nesse exemplo, o filter seleciona os alunos com menos de 30 anos de idade e os armazena em um array. "aluno" representa um elemento do array.

    Map: (array).map([função]) = executa uma mesma função para todos os elementos de um array, formando um novo array.

    Reduce = (array).reduce([função], valor inicial) = forma uma única variável com todos os valores ou strings selecionados de um array.
      Ex.: idadeTotal = alunos.reduce(idadeDaTurma, 0)

           function idadeDaTurma(total, aluno){
             return total + aluno.idade;
           }
           
        Nesse exemplo, a idade de todos os elementos do array "alunos" está sendo somada e armazenada em uma única variável (idadeTotal).
        Na função a ser executada dentro do reduce, é necessário passar, além do nome da função, o valor inicial de "total" (nesse exemplo), que pode ser um número, uma string ou outro.
    
    (array).slice() = corta uma parte do array. Se não é passado nada para o slice, ele faz uma cópia do array.
    [...(array)] = faz uma cópia de um array.

    Object.assign({}, [objeto]) = faz uma cópia de um objeto.
    {...(objeto)} = faz uma cópia de um objeto.

    Spread Operator = é os "três pontinhos" utilizados para se copiar um array ou um objeto. Também permite, além de copiar, adicionar novas informações à cópia e mesclar dois ou mais arrays ou objetos.
      Ex.: var copia = {...pessoa} = copia o objeto "pessoa".
           var copia = {...pessoa, cidade: Rio de Janeiro} = copia o objeto "pessoa" e adiciona a propriedade cidade à cópia.
           var copia = {...pessoa, ...contato} = junta os objetos "pessoa" e "contato" em um único objeto.

    Desestruturando um objeto: 
      var { (propriedade) } = (objeto) : seleciona uma ou mais propriedades do objeto e as armazena em uma variável de mesmo nome.
        Ex.: var { matrícula, nome } = aluno
      
      OBS.: selecionar o objeto inteiro faz uma cópia completa do mesmo, mas selecionar uma propriedade específica faz com que essa propriedade se separe da cópia.
        Ex.: var {nome, ...copia } = aluno

          Nesse exemplo, a copia irá ser formada apenas pelas propriedades restantes do objeto, já que a propriedade nome foi anteriormente selecionada e "retirada".

    Desestruturando um array: 
      var [(elemento do array)] = alunos : seleciona um elemento do array baseado em sua posição e o armazena em uma variável de nome personalizável.
        Ex.: var alunos = [aluno, aluno1] 
             var [marcos, joao] = alunos

           Nesse exemplo, marcos recebe aluno e joao recebe aluno1, pois a posição é o que importa nos arrays.

    
    Try Catch: 
      O "Try Catch" é uma forma de tratamento de erros que executa o código de "catch" se o código de "try" retornar um erro e logo após prossegue a execução do resto do código. O argumento passado para "catch" é o ReferenceError. Após o bloco do "catch" é possível utilizar o "finally", que executa um bloco de código independente de haver erro ou não.

        try { 
          bloco de código 
        } catch (argumento) {
          bloco de código
        }
        resto do código

        OU

        try { 
          bloco de código (tenta ser executado e retorna sucesso ou falha)
        } catch (argumento) {
          bloco de código (executado se houver falha)
        } finally {
          bloco de código (executado sempre)
        }
      
      Throw: é uma propriedade que pode ser utilizada dentro de "try" para forçar um erro. Em caso de erro, o throw irá executar o código de "catch" juntamente com seu próprio código.
        Ex.: 
          try {
            if (nome == "") {
              throw "O nome não pode ser vazio"
            }
            console.log(nome)
          } catch (erro) {
            console.log("Houve um erro", erro)
          }
      
    jQuery
      Importar do Google (https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js)

      Sintaxe: $("(seletor)").[metodo]()
        Obs.: os seletores são semelhantes ao CSS (. = class, # = id)
        
        IMPORTANTE: o símbolo "$" também é bastante usado por outras tecnologias. Por isso, existe o método "$.noConflict()", que faz com que o seletor do jQuery deixe de ser "$" e passe a ser "jQuery". Também é possível atribur esse método a uma variável e, assim, o jQuery passa a ser chamado a partir do nome dessa variável.

      Métodos importantes do jQuery: 
        hide,
        show,
        click,
        mouseenter,
        mouseleave,
        dblclick (double click),
        fadeIn,
        fadeOut,
        fadeTo,
        fadeToggle,
        slideDown,
        slideUp,
        slideToggle,
        animate,
        stop,
        find,
        children,
        text, 
        html,
        val (value),
        attr (attribute),   