
  HTML

    negrito = <b> (formatação) e <strong> (semântica de destaque)
    itálico = <i> (formatação) e <em> (semântica de destaque)
    texto riscado = <del>
    marca-texto = <mark>
    letra pequena = <small>
    texto mais "baixo" na linha = <sub>
    texto que foi inserido na página (fica sublinhado) = <ins>

    <figure> (tag usada para "agrupar" uma imagem com sua legenda)
    <img src="" alt="">
    <figcaption></figcaption> (aqui vai a legenda da imagem)
    </figure>

    link para número de telefone: 
      <a href="tel:+(numero)"></a>
        
    link para o app do Whatsapp: 
      <a href="whatsapp://(numero)"></a>

    link para o app do Instagram:
      <a href="instagram://"></a>  (abre o feed do Instagram)
      <a href="instagram://user?username=(perfil)"></a> (abre o perfil especificado)

    link para mandar email: 
      <a href="mailto:(endereço de email)"></a>

    direcionar o usuário para algum conteúdo específico da página:
      <a href="#(id atribuído ao conteúdo)"></a>

    adicionar vídeo: 
      <video src=""></video>
        atributos: 
          não precisam de valor: controls, autoplay, muted, loop,
          precisam de valor: width, height, poster = src(""), preload = "auto" (inicia o carregamento do vídeo após a página carregar) / "none" (não carrega o vídeo enquanto o usuário não der play) / "metadata" (carrega apenas alguns dados sobre o vídeo)
          Obs.: quando preload e autoplay são usados juntos, o autoplay possui prioridade
                              
  CSS

    conteúdo em excesso ("vazando" do lugar onde deveria estar):
    overflow/overflow-y/overflow-x: auto (adiciona automaticamente uma barra de rolagem) / scroll (adiciona um barra de rolagem) / hidden (esconde o conteúdo em excesso)

    colocar imagem em lista não ordenada (a imagem PRECISA ser 16x16):
      list-style-image: url('(imagem)');
      
    Position
      static: padrão, não permite uso de top, bottom, left, right.

      Permitem uso de top, bottom, left, right:

        relative: posição com base no posicionamento original do elemento. É como se o elemento definido como relative ainda estivesse ocupando seu espaço original, mesmo não estando nele.

        absolute: se posiciona de acordo com o elemento pai, desde que este não tenha posicionamento static. Se o pai tiver posicionamento static, o elemento se posicionará em relação ao primeiro elemento não estático acima dele. É como se o elemento definido como absolute funcionasse de forma independente, sem afetar a posição de outros elementos.

        fixed: mantém o elemento fixo em relação à viewport. O elemento é removido de sua posição original, funcionando de forma independente.

        sticky: o elemento mantém seu posicionamento original, porém continua na tela caso saia da viewport.

    Variáveis
      :root {
        --(nome da variável): (valor);
      }

      (elemento) {
        (propriedade): var(--(nome da variavel));
      }

        Ex.: 
          :root {
            --cor: red;
          }

          div {
            background-color: var(--cor);
          }

    Flexbox
      Aplicáveis ao elemento pai: 
        display: flex = organiza os elementos filhos de forma que possam ser contidos dentro do elemento pai, mesmo que seja necessário alterar seus tamanhos para isso

        flex-direction: 
          row = o elemento que recebe "flex-direction: row" se comporta como uma grande linha com orientação da esquerda para a direita, onde seus elementos filhos se organizam de forma a ficar dentro dessa linha. Para isso, cada elemento filho se torna uma coluna e, por padrão, irá ocupar toda a altura do elemento pai

          row-reverse = similar ao row, porém a orientação da linha é da direita para a esquerda, a ordem dos elementos é invertida e os elementos são fixados à direita

          column = o elemento que recebe "flex-direction: column" se comporta como uma grande coluna com orientação de cima para baixo, onde seus elementos filhos se organizam de forma a ficar dentro dessa coluna. Para isso, cada elemento filho se torna uma linha e, por padrão, irá ocupar toda a largura do elemento pai

          column-reverse = similar ao column, porém a orientação da coluna é de baixo para cima, a ordem dos elementos é invertida e os elementos são alocados para a parte de baixo

        flex-wrap: wrap = mantém o tamanho definido dos elementos e forma mais linhas ou colunas para contê-los

        flex-wrap: wrap-reverse = inverte a ordem das linhas ou colunas e as posiciona ao lado contrário do natural

        flex-flow: (flex-direction flex-wrap) = redução das propriedades flex-direction e flex-wrap em uma só propriedade

      justify-content: posiciona os elementos filhos em relação ao elemento pai
        flex-start = padrão

        flex-end = fixa os elementos na extremidade "final" do elemento pai

        center = centraliza os elementos

        space-around = faz uma borda ao redor do elemento com medidas iguais nos dois lados

        space-between = mantém espaçamento uniforme entre os elementos

        space-evenly = mantém espaçamento uniforme entre a borda e os elementos e também entre os elementos

      align-items: alinha os elementos de acordo com o flex-direction. Caso seja row, alinhará os elementos verticalmente, caso seja column, alinhará os elementos horizontalmente
        stretch = padrão

        flex-start = posiciona os elementos no início da linha

        flex-end = posiciona os elementos no fim da linha ou coluna

        center = centraliza os elementos

      align-content: similiar ao align-items, porém não se aplica aos elementos, mas sim às linhas ou colunas.
        stretch = padrão

        center = centraliza as linhas/colunas

        flex-start = posiciona as linhas/colunas no início do elemento pai

        flex-end = posiciona as linhas/colunas no fim do elemento pai

        space-around = faz uma borda ao redor das linhas/colunas com medidas iguais nos dois lados

        space-between = mantém espaçamento uniforme entre as linhas/colunas

    Aplicáveis aos elementos filhos:
      flex-shrink: 0 / 1 (padrão) = define se o tamanho do elemento será passível de redução (0 = não flexível / 1 = flexível)

      flex-grow: 0 (padrão) / 1 = define se o tamanho do elemento será passível de expansão (0 = não flexível / 1 = flexível / <= 2 = multiplicador de tamanho)

  JavaScript

    Objetos

      Declaração:
        var (nome do objeto) = {propriedade: valor}
          Ex.: var aluno = {nome: "Igor", nota1: 7.5}
      
      Acessando propriedades de um objeto:
        (nome do objeto).(propriedade) / (nome do objeto)["(propriedade)"]
          Ex.: aluno.nome / aluno["nome"]

      Um objeto pode ter arrays dentro de si.
        Ex.: var aluno = {notas[1.5, 2.0, 3.5]}
        console.log(aluno.notas / aluno["notas"])= mostra todo o vetor "notas"
        console.log(aluno.notas[x] / aluno["notas"][x]) = mostra um valor específico do vetor "notas"

      Inserindo propriedades em um objeto já existente:
        (nome do objeto).(nova propriedade) = (valor)
        (nome do objeto)["(nova propriedade)"] = (valor)
        var x = (nova propriedade) -> (nome do objeto).x = (valor)
                                      (nome do objeto)[x] = (valor)

      Funções em objetos (métodos):
        var (nome do objeto) = {(propriedade que recebe o método) = function(){}}
        Ex.: var objeto = {
                media = function(n1, n2){
                  return (n1 + n2) / 2
                }
              }

            OU

            var objeto = {
              media = calcMedia
            }

            function calcMedia(n1, n2) {
              return (n1 + n2) / 2
            }

        elemento "this": se refere ao objeto em que ele está inserido. É usado nos métodos para 

    document.getElementById("(id do elemento)")
    document.getElementsByClassName("(class)") = forma um array com todos os elementos da classe especificada
    document.getElementsByTagName("h1") = forma um array com todos os elementos da tag especificada

    .innerHTML = conteúdo HTML do elemento (incluindo tags)
    .innerText = apenas o texto que está sendo mostrado
    .textContent = tudo aquilo que está dentro do texto

    Modificando elementos HTML:
      (elemento).(atributo) = "(valor)"
        Ex.: p.style = "color:blue"
        Ex.2: p.className = "paragrafo"

    Acessando atributos de um elemento HTML:
      (elemento).getAttribute("(atributo)")
        Ex.: p.getAttribute("meuAtt")

    Modificando ou adicionando atributos a um elemento HTML:
      (elemento).setAttribute("(atributo)", "(valor)")
        Ex.: p.setAttribute("meuAtt", "novo nome")
        IMPORTANTE: quando for utilizar um atributo inventado, colocar 
        "data-(atributo)" no HTML e selecioná-lo no JS utilizando (elemento).dataset.(atributo)
          Ex.: HTML = <ul id="lista" data-num="5"></ul> / JS = lista.dataset.num

    Modificando ou adicionando estilos CSS a um elemento HTML: 
      (elemento).style.(tag CSS) = "(valor)"
        Ex.: p.style.backgroundColor = "red"

    Acessando os elementos filhos de um elemento pai:
      (elemento).children = forma um array com todos os elementos filhos
      (elemento).children[x] = pega um elemento específico do array de filhos

    Acessando o elemento pai de um elemento filho:
      (elemento).parentElement

    *Biblioteca importante: Math

    JSON:

      JSON.stringify() = transforma um objeto em uma string
      JSON.parse() = transforma uma string em um objeto

    Local Storage (guarda os dados em uma string e os mantém mesmo após reiniciar a página):

      localStorage.setItem("(chave)", "(string)") = guarda o dado

      localStorage.getItem("(chave)") = busca o dado solicitado que foi guardado anteriormente

      localStorage.removeItem("(chave)") = remove o dado da memória

      localStorage.clear() = apaga toda a memória

      OBS.: os dados só ficam disponíveis dentro de seu próprio domínio.
      OBS2.: usar JSON para converter os dados que não são strings.
    
    Temporizador e Intervalo:

      Temporizador: setTimeout((funcao), tempo (em milissegundos)) = depois de disparado, executa uma função após o tempo determinado

      Intervalo: setInterval((funcao), tempo (em milissegundos)) = depois de disparado, executa uma função repetidamente de acordo com o intervalo de tempo determinado

      Interromper setTimeout: clearTimeout((variável correspondente ao timeout))

      Interromper setInterval: clearInterval((variável correspondente ao interval))

    Vídeos

      .play() = iniciar/continuar o vídeo
      .pause() = pausar o vídeo
      .currentTime = define ou retorna o momento atual do vídeo
      .playbackRate = velocidade de reprodução do vídeo

    Canvas
      Importante: definir o tamanho do canvas na própria tag HTML (<canvas>) e não pelo CSS

      Necessário pegar o contexto
        Ex.: let tela = document.getElementById("tela")
             let ctx = tela.getContext("2d")

      (contexto).moveTo(x, y) = coloca o "pincel" na coordenada especificada
        Ex.: ctx.moveTo(0, 0)
      
      (contexto).lineTo(x, y) = traça uma linha do ponto inicial do contexto até a coordenada especificada
        Ex.: ctx.lineTo(250, 250)

      (contexto).stroke() = desenha a linha. Obrigatório para a linha aparecer.

      (contexto).strokeStyle = "(valor)" -> define estilo para a linha.
        Ex.: ctx.strokeStyle = "red"

      (contexto).lineWidth = (valor) -> define a largura da linha. Obrigatório vir antes do stroke.

      Retângulos:

        Preenchido:
          (contexto).fillRect(x, y, width, height) -> define onde será iniciado o retângulo (preenchido) e suas respectivas largura e altura

          (contexto).fillStyle = "(valor)" -> define o estilo do preenchimento do retângulo

        Vazio: 
          (contexto).strokeRect(x, y, width, height) -> define onde será iniciado o retângulo (vazio) e suas respectivas largura e altura

          (contexto).strokeStyle = "(valor)" -> define o estilo da borda do retângulo
        
        Preenchido e borda com estilos diferentes: 
          (contexto).rect(x, y, width, height) -> define onde será iniciado o retângulo (vazio) e suas respectivas largura e altura

          (contexto).fillStyle = "(valor)" -> define o estilo do preenchimento do retângulo

          (contexto).strokeStyle = "(valor)" -> define o estilo da borda do retângulo

          (contexto).fill() = define o preenchimento (faz ele aparecer)
          (contexto).stroke() = define a borda (faz ela aparecer)

          (contexto).clearRect(x, y, width, height) -> cria um espaço vazio dentro do retângulo

    (contexto).beginPath() -> cria um caminho (duas ou mais linhas seguidas. Ex.: uma linha começa em 0,0 e vai até 10,10; então cria-se uma segunda linha que, ao invés de começar em 0,0; começa em 10,10; onde a primeira linha terminou, e vai até 20,20)

    (contexto).closePath() -> cria linhas que fecham o caminho automaticamente.

    Círculos / Arcos
      Importante: Necessário criar um caminho para fazer círculos ou arcos

      (contexto).arc(x, y, raio, angulo inicial, angulo final)
        OBS.: x e y representam o ponto central do círculo; os ângulos são medidos em radianos; usar variáveis para passar os valores do círculo.

    Animação 

      Ver aula: https://programadorbr.club.hotmart.com/lesson/qoODn0zgeP/canvas-animacao

    Imagens dentro de canvas

      Primeira maneira:
        1. Definir imagem no HTML com display: none 
        2. (contexto).drawImage((variável com a imagem), x, y, width, height)

      Segunda maneira:
        1. Definir variável com valor "new Image()"
        2. (variável).src = "(imagem)"
        3. (variável).onload = (funcao)
        4. funcao {(contexto).drawImage(this, x, y, width, height)} 
          Obs.: também é possível usar this.naturalWidth no lugar de width e this.naturalHeight no lugar de height (e fazer operações com esses tamanhos)